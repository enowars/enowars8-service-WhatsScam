from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad
import random
import datetime
import rsa
from cryptography.hazmat.primitives.asymmetric import rsa as crsa
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives import hashes
import math


def key_exploit(seed):
    random.seed(seed)
    def not_so_random():
        random_number = random.randint(0, 2**128 - 1)
        return random_number.to_bytes(16, byteorder='big')

    key = not_so_random()
    nonce = not_so_random()
    return key, nonce

def insecure_aes_decrypt(ciphertext, seed):
    seed = seed
    key, nonce = key_exploit(seed)
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
    padded_plaintext = cipher.decrypt(ciphertext)
    plaintext = unpad(padded_plaintext, AES.block_size)
    return plaintext
    #return plaintext

def expprime(cipher, publickey):
    n = publickey.n
    e = publickey.e
    p = math.isqrt(n + 4)-2
    q = p + 4
    # Calculate private exponent
    d = rsa.common.inverse(e, (p-1)*(q-1))

    # Generate RSA key object
    private_key = rsa.PrivateKey(n, e, d, p, q)
    #print("Private key: ", private_key.save_pkcs1().decode())

    # Decrypt message with private key
    plaintext = rsa.decrypt(cipher, private_key)
    print("Decrypted message:")
    print(plaintext.decode())





